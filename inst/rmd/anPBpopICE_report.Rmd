---
output:
  html_document:
    df_print: paged
    fig_caption: true
params:
  rawfolder: ''
  AOInm: ''
  T1: ''
  T2: ''
  REMPER: ''
  QAQC.self: ''
  QAQC.cross: ''
  outfn.pre: ''
---

```{r info, include=FALSE, echo=FALSE} 


## Adjust margins and other document settings in reference_docx: ICE_Summary_RMARKDOWN_TEXT_STYLE_REFDOC.docx
## For example, header 14 is ##############

#=================================================================================
# Load R packages needed:
#=================================================================================

# suppressMessages loads in packages quietly, so that loading messages do not get sent to document 
suppressMessages(library(knitr))
#suppressMessages(library(gridExtra))
suppressMessages(library(data.table))
suppressMessages(library(pheatmap))


## Define functions from FIESTA
#wraptitle <- function(x, len=10) {
#  sapply(x, function(y) paste(strwrap(y, len), 
#         collapse = "\n"), USE.NAMES = FALSE)
#}


#=================================================================================
# Important Info (1/11/2021)
#=================================================================================
# Revised slightly to incorporate as template in FIESTA - Tracey Frescino
# 1. Changed code for inputs to parameters
# 2. Change method for importing rawdata *.csv files so not to have to include dates
# 3. Change method for defining LU/LC classes (an attempt to make more generic), using classes from Input6 and Input10
# 4. Using FIESTA function above (wraptitle) for create class labels
# 5. Removed getrange and getmap functions, not using anymore
# 6. In plotNetChangesByClass, plotGainLossSingClass functions, and plotCheckerboard functions changed input of inFile from file name to already imported object data frame.
# 7. In, plotCheckerboard functions, added arguments to specify name of land use and land cover variables (an attempt to make more generic).
# 8. Used generic variable object names in summaryInfo
# 9. Changed state parameter to AOInm.
# 10. Got rid of unnecessary libraries (stringr, dply, rgeos, RColorBrewer, gridExtra, raster, OpenStreeMap).
# 11. Using d instead of mat for pheatmap


#=========================================================================================================
# TABLE OF CONTENTS --- Code Chunks --- Can search different chunks/functions (e.g. ctr+f "r setup chunk")  
#=========================================================================================================
# 1. r setup chunk: All directories, unique objects (state), and input data are in the first chunk of code (this chunk)
# 2. r customFunc chunk: All custom data & plot functions
#    *Data Functions
#       -  1. getmap
#       -  2. plotNetChangesByClass
#       -  3. plotGainLossSingClass
#    *Plot Functions 
#       -  1. getmap
#       -  2. plotNetChangesByClass
#       -  3. plotGainLossSingClass 
# 3. r iceOverviewGraphicCapGen chunk: This chunk creates Figure 1
# 4. r getSummaryInfo chunk: This chunk creates an empty datatable that is populated with LC and LU data from the Fiesta estimates --> nostrata --> rawdata folder. The table info is used for plots 
# 5. r luNetChange chunk: Creates Figure 2
# 6. r luForGainLoss_tab3 chunk: Creates Figure 3
# 7. r lcNetChange chunk: Creates Figure 4
# 8. r lcTreeGainLoss chunk: Creates Figure 5
# 9. r chgAgBarChart chunk: Creates Figure 6
# 10. r T2-LCover_LUse chunk: Creates Figure 7
# 11. used d instead of mat for pheatmap


##*** Adjust figure size with -- ```{r, fig.align = "center", fig.height = 8, fig.width = 8,
    ## out.width = "8.5in"}
## Refer to this guide for more rmarkdown code https://rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf



#############--- FILE/DATA INPUTS ---###########################################
# Use ctr+f to find where inputs are loaded in (code below), and used in code 
# ------------------------------------------------------------------------------

#### Directories, State, Years, File name inputs ####
# INPUT 1. State name -- !!! Have to update this input 
# INPUT 2. Years of NAIP imagery  
# INPUT 3. Unique file name "year0101" (i.e. year, two digit month, two digit day) --unique file identifier used later to input correct data   
# INPUT 4. FIA data
# INPUT 5. Master" plot data

#### Forest LU and LC inputs ####
# INPUT 6. Land Use (LU) data for Time 1 (T1: Year 1) 
# INPUT 7. Land Use (LU) data for Time 2 (T2: Year 2)  
# INPUT 8: LU net change and uncertainty associated w/ LU net change
# INPUT 9: LU change decrease or increased, and type of LU that increased/decreased
# INPUT 10: Percent of Tree Landcover (LC) for T1 (Year 1)
# INPUT 11: Percent of Tree Landcover (LC) for T2 (Year 2)
# INPUT 12: Tree LC Net Change and Tree LC net change uncertainty
# INPUT 13: Overall tree LC increase or decrease -- What forest changed to for T1 and T2 (year1 and year 2)

#### Figure Inputs #####
# Input 14: Net Land use change among all LU classes (Figure 2)
# Input 15: Forest Land Use Change input (Figure 3)
## Input 16: Net Land Cover Change Among All Classes (Figure 4)
# Input 17: Forest Land Use Change input (Figure 5) 
## Input 18: Forest Land Use Change input (Figure 6) 

```



```{r inputs, echo=FALSE, warning=FALSE, message=FALSE}
library(FIESTA)
rawfolder <- params$rawfolder
AOInm <- params$AOInm
yearT1 <- params$T1
yearT2 <- params$T2
REMPER <- params$REMPER
QAQC.self <- params$QAQC.self
QAQC.cross <- params$QAQC.cross
outfn.pre <- params$outfn.pre

# ## Set the following parameters to run report
# rawfolder <- "C:/_tsf/FIESTA_testing/PBmodule/ME_2015_2018/FIESTA_20230210/estimates/rawdata"
# AOInm <- "Maine"
# yearT1=T1 <- 2015
# yearT2=T2 <- 2018
# REMPER <- 3.0
# QAQC.self <- NULL
# QAQC.cross <- NULL
# outfn.pre <- AOInm


if (is.null(rawfolder) || rawfolder == "") stop("rawfolder is NULL")
if (!dir.exists(rawfolder)) stop("rawfolder path is invalid")
if (is.null(AOInm) || AOInm == "") stop("AOInm is NULL")
if (is.null(yearT1) || T1 == "") stop("T1 is NULL")
if (is.null(yearT2) || T1 == "") stop("T2 is NULL")
if (is.null(outfn.pre) || outfn.pre == "") outfn.pre <- AOInm
if (is.null(REMPER) || REMPER == "") REMPER <- (yearT2 - yearT1)

## Check QAQC data
# if (is.null(QAQC.self)) {
#   QAQC.self <- NULL
# } else {
#   if (all(!is.vector(QAQC.self), !is.numeric(QAQC.self), length(QAQC.self) != 4)) {
#     warning("QAQC.self must be a vector of 4 numbers")
#     QAQC.self <- NULL
#   } else if (!all(QAQC.self > 0 & QAQC.self < 100)) {
#     warning("all values of QAQC.self must be between 0 and 100")
#     QAQC.self <- NULL
#   }    
# }
# if (is.null(QAQC.cross)) {
#   QAQC.cross <- NULL
# } else {
#   if (all(!is.vector(QAQC.cross), !is.numeric(QAQC.cross), length(QAQC.cross) != 4)) {
#     warning("QAQC.cross must be a vector of 4 numbers")
#     QAQC.cross <- NULL
#   } else if (!all(QAQC.cross > 0 & QAQC.cross < 100)) {
#     warning("all values of QAQC.cross must be between 0 and 100")
#     ice.QAQC <- NULL
#   }    
# }


#if (is.null(outfolder)) outfolder <- rawfolder
figNum <- 0


## Define function to wrap text
wraptitle <- function(x, len=10) {
  sapply(x, function(y) paste(strwrap(y, len),
         collapse = "\n"), USE.NAMES = FALSE)
}

```


```{r setup, include=FALSE, echo=FALSE} 


#rawfolder <- normalizePath(rawfolder)

#### INPUT 6: Land Use (LU) data for Time 1 (T1: Year 1) #### 
# -------------------------------------------------------------------------------------
Input6 <- list.files(rawfolder, pattern=utils::glob2rx("03*unit*rowest*csv"))
Input6 <- read.csv(file.path(rawfolder, Input6[length(Input6)]), stringsAsFactors=FALSE, check.names=FALSE)

## Define variable names in raw tables
if ("use_1_nm" %in% names(Input6)) {
  use1nm <- "use_1_nm"
  use2nm <- "use_2_nm"
  cover1nm <- "cover_1_nm"
  cover2nm <- "cover_2_nm"
  agentnm <- "chg_ag_2_GRP_nm"
} else {
  use1nm <- "T1-Use"  # "use_1_nm"
  use2nm <- "T2-Use"  # "use_2_nm"
  cover1nm <- "T1-Cover"  # "cover_1_nm"
  cover2nm <- "T2-Cover"  # "cover_2_nm"
  agentnm <- "Change Agent-GRP"  # "chg_ag_2_GRP_nm"
}
use1cd <- "use_1"
use2cd <- "use_2"
cover1cd <- "cover_1"
cover2cd <- "cover_2"
agentcd <- "chg_ag_2_GRP"

#### INPUT 7: Land Use (LU) data for Time 2 (T2: Year 2) ####
# --------------------------------------------------------------------------------------
Input7 <- list.files(rawfolder, pattern=utils::glob2rx("04*unit*rowest*csv"))
Input7 <- read.csv(file.path(rawfolder, Input7[length(Input7)]), stringsAsFactors=FALSE, check.names=FALSE)

#### INPUT 8: LU net change and uncertainty associated w/ LU net change ####
# -------------------------------------------------------------------------------------
Input8 <- list.files(rawfolder, pattern=utils::glob2rx("09*gainloss*csv"))
Input8 <- read.csv(file.path(rawfolder, Input8[length(Input8)]), stringsAsFactors=FALSE, check.names=FALSE)

#### INPUT 9: LU change decrease or increased, and type of LU that increased/decreased #####
# -----------------------------------------------------------------------------------------------
Input9 <- list.files(rawfolder, pattern=utils::glob2rx("09*unit*grpest*csv"))
Input9 <- read.csv(file.path(rawfolder, Input9[length(Input9)]), stringsAsFactors=FALSE, check.names=FALSE)

#### INPUT 10: Percent of Tree Landcover (LC) ####
# -----------------------------------------------------------------------------------------------
Input10 <- list.files(rawfolder, pattern=utils::glob2rx("05*unit*rowest*csv"))
Input10 <- read.csv(file.path(rawfolder, Input10[length(Input10)]), stringsAsFactors=FALSE, check.names=FALSE)

#### INPUT 11: Percent of Tree Landcover (LC) for T2 (Year 2) ####
# ----------------------------------------------------------------------------------------------
Input11 <- list.files(rawfolder, pattern=utils::glob2rx("06*unit*rowest*csv"))
Input11 <- read.csv(file.path(rawfolder, Input11[length(Input11)]), stringsAsFactors=FALSE, check.names=FALSE)

#### INPUT 12: Tree LC Net Change and Tree LC net change uncertainty ####
# ----------------------------------------------------------------------------------------------
Input12 <- list.files(rawfolder, pattern=utils::glob2rx("10*gainloss*csv"))
Input12 <- read.csv(file.path(rawfolder, Input12[length(Input12)]), stringsAsFactors=FALSE, check.names=FALSE)

#### INPUT 13: Overall tree LC increase or decrease -- What forest changed to for T1 and T2 (year1 and year 2) ####
# ----------------------------------------------------------------------------------------------
Input13 <- list.files(rawfolder, pattern=utils::glob2rx("10*unit*grpest*csv"))
Input13 <- read.csv(file.path(rawfolder, Input13[length(Input13)]), stringsAsFactors=FALSE, check.names=FALSE)

#### Input 14: Net Land use change among all LU classes (Figure 2) 
# ----------------------------------------------------------------------------------------------
Input14 <- list.files(rawfolder, pattern=utils::glob2rx("09*gainloss*csv"))
Input14 <- read.csv(file.path(rawfolder, Input14[length(Input14)]), stringsAsFactors=FALSE, check.names=FALSE)

## Input 15: Forest Land Use Change input (Figure 3) 
# ----------------------------------------------------------------------------------------------
Input15 <- list.files(rawfolder, pattern=utils::glob2rx("07*gainloss*csv"))
Input15 <- read.csv(file.path(rawfolder, Input15[length(Input15)]), stringsAsFactors=FALSE, check.names=FALSE)

## Input 16: Net Land Cover Change Among All Classes (Figure 4)
# ----------------------------------------------------------------------------------------------
Input16 <- list.files(rawfolder, pattern=utils::glob2rx("10*gainloss*csv"))
Input16 <- read.csv(file.path(rawfolder, Input16[length(Input16)]), stringsAsFactors=FALSE, check.names=FALSE)

## Input 17: Forest Land Use Change input (Figure 5) 
# ----------------------------------------------------------------------------------------------
Input17 <- list.files(rawfolder, pattern=utils::glob2rx("08*gainloss*csv"))
Input17 <- read.csv(file.path(rawfolder, Input17[length(Input17)]), stringsAsFactors=FALSE, check.names=FALSE)

## Input 18: Forest Land Use Change input (Figure 6) 
# ----------------------------------------------------------------------------------------------
Input18 <- list.files(rawfolder, pattern=utils::glob2rx("02*unit*rowest*csv"))
Input18 <- read.csv(file.path(rawfolder, Input18[length(Input18)]), stringsAsFactors=FALSE, check.names=FALSE)

## Input 19: Checkerboard figure (Figure 7) 
# ----------------------------------------------------------------------------------------------
Input19 <- list.files(rawfolder, pattern=utils::glob2rx("09*unit*grpest*csv"))
Input19 <- read.csv(file.path(rawfolder, Input19[length(Input19)]), stringsAsFactors=FALSE, check.names=FALSE)
Input19a <- list.files(rawfolder, pattern=utils::glob2rx("09*unit*rowest*csv"))
Input19a <- read.csv(file.path(rawfolder, Input19a[length(Input19a)]), stringsAsFactors=FALSE, check.names=FALSE)
Input19b <- list.files(rawfolder, pattern=utils::glob2rx("09*unit*colest*csv"))
Input19b <- read.csv(file.path(rawfolder, Input19b[length(Input19b)]), stringsAsFactors=FALSE, check.names=FALSE)
Input19c <- list.files(rawfolder, pattern=utils::glob2rx("09*unit*totest*csv"))
Input19c <- read.csv(file.path(rawfolder, Input19c[length(Input19c)]), stringsAsFactors=FALSE, check.names=FALSE)

df19 <- Input19[, c(use1cd, use1nm, use2cd, use2nm, "est", "est.var", "est.se")]
df19 <- rbindlist(list(df19, data.frame(Input19a[, c(use1cd, use1nm)], 9999, "TOTAL", Input19a[, c("est", "est.var", "est.se")])), use.names=FALSE)
df19 <- rbindlist(list(df19, data.frame(9999, "TOTAL", Input19b[, c(use2cd, use2nm, "est", "est.var", "est.se")])), use.names=FALSE)
df19 <- rbindlist(list(df19, data.frame(9999, "TOTAL", 9999, "TOTAL", Input19c[, c("est", "est.var", "est.se")])), use.names=FALSE)


## Input 20: Checkerboard figure (Figure 8) 
# ----------------------------------------------------------------------------------------------
Input20 <- list.files(rawfolder, pattern=utils::glob2rx("10*unit*grpest*csv"))
Input20 <- read.csv(file.path(rawfolder, Input20[length(Input20)]), stringsAsFactors=FALSE, check.names=FALSE)
Input20a <- list.files(rawfolder, pattern=utils::glob2rx("10*unit*rowest*csv"))
Input20a <- read.csv(file.path(rawfolder, Input20a[length(Input20a)]), stringsAsFactors=FALSE, check.names=FALSE)
Input20b <- list.files(rawfolder, pattern=utils::glob2rx("10*unit*colest*csv"))
Input20b <- read.csv(file.path(rawfolder, Input20b[length(Input20b)]), stringsAsFactors=FALSE, check.names=FALSE)
Input20c <- list.files(rawfolder, pattern=utils::glob2rx("10*unit*totest*csv"))
Input20c <- read.csv(file.path(rawfolder, Input20c[length(Input20c)]), stringsAsFactors=FALSE, check.names=FALSE)

df20 <- Input20[, c(cover1cd, cover1nm, cover2cd, cover2nm, "est", "est.var", "est.se")]
df20 <- rbindlist(list(df20, data.frame(Input20a[, c(cover1cd, cover1nm)], 9999, "TOTAL", Input20a[, c("est", "est.var", "est.se")])), use.names=FALSE)
df20 <- rbindlist(list(df20, data.frame(9999, "TOTAL", Input20b[, c(cover2cd, cover2nm, "est", "est.var", "est.se")])), use.names=FALSE)
df20 <- rbindlist(list(df20, data.frame(9999, "TOTAL", 9999, "TOTAL", Input20c[, c("est", "est.var", "est.se")])), use.names=FALSE)

## Input 21: Table Estimated percent of T2-Cover within T2-Use (Figure 9) 
# ----------------------------------------------------------------------------------------------
Input21.n <- list.files(rawfolder, pattern=utils::glob2rx("13a*unit*grpest*csv"))
Input21.n <- read.csv(file.path(rawfolder, Input21.n[length(Input21.n)]), stringsAsFactors=FALSE, check.names=FALSE)

Input21 <- list.files(dirname(rawfolder), pattern=utils::glob2rx("13a*csv"))
Input21 = read.csv(file.path(dirname(rawfolder), Input21[length(Input21)]), stringsAsFactors=FALSE, 
            skip = 3, nrows = length(unique(Input21.n[[cover2nm]])), check.names=FALSE)


## Input 22: Table Estimated percent of T2-Cover within T2-Use  (Figure 10) 
# ----------------------------------------------------------------------------------------------
Input22.n <- list.files(rawfolder, pattern=utils::glob2rx("13b*unit*grpest*csv"))
Input22.n <- read.csv(file.path(rawfolder, Input22.n[length(Input22.n)]), stringsAsFactors=FALSE, check.names=FALSE)

Input22 <- list.files(dirname(rawfolder), pattern=utils::glob2rx("13b*csv"))
Input22 = read.csv(file.path(dirname(rawfolder), Input22[length(Input22)]), stringsAsFactors=FALSE, 
            skip = 3, nrows = length(unique(Input22.n[[cover2nm]])), check.names=FALSE)


#==========================================================================
# Set some global defaults 
#==========================================================================

#### knitr global chunk options #####

# Set knitr chunk options to be applied throughout document. Prevents user from having to re-write the options in every code "chunk"
# echo = FALSE --- no code shown -- Good for scientific reports when people do not want to see the code 
# Here width and height of all figures is set
# !!!! Can change specific figure dimensions in the figure creation chunks !!!!

#knitr::opts_chunk$set(echo = TRUE)
#--------------------------------------------------------------------------
knitr::opts_chunk$set(fig.width=8)
knitr::opts_chunk$set(fig.height=6)
knitr::opts_chunk$set(dev = 'svg', fig.path = "figs/", dpi=300) # set output device to svg


#==========================================================================
# Figure settings ---- lables, etc. 
#==========================================================================

# Define ICE LU/LC classes and "pretty" labels for use in figures
# ----------------------------------------------------------------

allLUClasses <- Input6[[use1nm]]
allLUClassLabs <- wraptitle(sub("/", "\n", allLUClasses), 8)
nLUClasses = length(allLUClasses)

allLCClasses <- Input10[[cover1nm]]
allLCClassLabs <- wraptitle(sub("/", "\n", allLCClasses), 10)
nLCClasses = length(allLCClasses)

```


```{r customFunc, include=FALSE} 
#=============================================================================
#****************************************************************************#
#### CUSTOM DATA AND PLOT FUNCTIONS ####
#****************************************************************************#
#=============================================================================
#  F  ########################################################################
##  U  #######################################################################
###  N  ######################################################################
####  C  #####################################################################
#####  T  ####################################################################
######  I  ###################################################################
#######  O  ##################################################################
########  N  #################################################################
#########  s  ################################################################

#=============================================================================
#### CUSTOM DATA FUNCTIONS ####
#=============================================================================
# 1. setDecPlaces
# 2. getNPrettyDecPlaces


# --> to specify the number of decimal places:
#     * Input(s): number to round, number of decimal places you want in the num
#     * Output(s): the number, w/ specificed n decimal places
setDecPlaces = function(x, k) format(round(x, k), nsmall=k) # x = number, k = num decimal places


# --> to get num "pretty" decimal places that would make a "pretty"-formatted number
#     (basically trailing zeroes trimmed)
#     * Input(s): a number!
#     * Output(s): number of decimal places that would make the number "pretty"
getNPrettyDecPlaces = function(x) {
  nPrettyDecPlaces = 0 # default = whole numbers
  x = as.character(abs(as.numeric(x)))

  fields = unlist(strsplit(x,".",fixed=TRUE)) # trims trailing zeroes by default?
  
  if (length(fields) > 1) { # decimal point was specified; get n decimal places to make num pretty
    nPrettyDecPlaces = nchar(fields[2]) 
  } # wholeNum check 
  
  return(nPrettyDecPlaces)    
} # end function getNPrettyDecPlaces



##********** END of DATA FUNCTIONS ***********************************###
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#


#=============================================================================
#### CUSTOM PLOT FUNCTIONS ####
#=============================================================================
# 1. plotNetChangesByClass
# 2. plotGainLossSingClass


#===============================================================================  
## plotNetChangesByClass function:  plot net changes in classes for LU and LC
#===============================================================================  

# Input(s): type of data (LU = Land Use, LC = Land Class), 
#               full path to and filename for input csv, figure title
#     Output(s): bar chart, with net change (gain, loss, no change/0%) for each 
#                LU or LC class, with uncertainty info (diff.CI95left,right)
plotNetChangesByClass = function(datatype='LU',inFile=NULL,figTitle="") {

  if (is.null(inFile)) {
    print(paste0("Provide the full path to and the filename of ",
          "the ICE LU or LC estimates via 'inFile'."))
    quit()
  }

  if (datatype == 'LU') {
    nClasses = nLUClasses
  } else if (datatype == 'LC') {
    nClasses = nLCClasses
  } else {
    print(paste0("Unrecognized ICE type ", datatype,".  Should be 'LU' or 'LC'"))    
    quit()
  }

  # read in data  
  tabInfo = inFile
  tabInfo$diff.SEleft <- tabInfo$diff.est - tabInfo$diff.se
  tabInfo$diff.SEright <- tabInfo$diff.est + tabInfo$diff.se

  # file structure change on 4/9/2018 in estimate files - code around these
  category = unlist(strsplit(tabInfo$gain.val,split=" to "))
  category = category[seq(2,length(category),by=2)] # get only even elements on the right hand side of the "to" equation

  tabInfo = cbind(category, tabInfo)
  
  # set up variables that will be used to make the plot
  barData = as.numeric(nClasses)
  barUncData = as.numeric(nClasses)
  barColors = as.character(nClasses)
  barLabels = as.character(nClasses)
  classLabCol = rep("black",nClasses)
  
  # populate barData, barColors, barLabels
  for (Idx in 1:nClasses) {

    if (datatype == 'LU') {    
    
      if (nrow(tabInfo[tabInfo[,1] == allLUClasses[Idx],]) == 0) {
        barData[Idx] = 0 # assume zero if not present in TF table
        barUncData[Idx] = 0
        barLabels[Idx] = ""
        classLabCol[Idx] = "darkgray" # combo doesn't exist in this AOI
      } else {
        barData[Idx] = tabInfo[tabInfo[,1] == allLUClasses[Idx],]$diff.est

        barUncData[Idx] = tabInfo[tabInfo[,1] == allLUClasses[Idx],]$diff.SEleft
        if (barData[Idx] > 0) {
          barUncData[Idx] = tabInfo[tabInfo[,1] == allLUClasses[Idx],]$diff.SEright
        }         
        
        if (barData[Idx] == 0) {
          barLabels[Idx] = paste0(setDecPlaces(barData[Idx],0),"%")  
        } else {
          barLabels[Idx] = paste0(setDecPlaces(barData[Idx],3),"%")  
        }

      } # end if/check for non-existent data
      
    } else if (datatype == 'LC') {

      if (nrow(tabInfo[tabInfo[,1] == allLCClasses[Idx],]) == 0) {
        barData[Idx] = 0 # assume zero if not present in TF table
        barUncData[Idx] = 0
        barLabels[Idx] = ""
        classLabCol[Idx] = "darkgray" # combo doesn't exist in this AOI
      } else {
        barData[Idx] = tabInfo[tabInfo[,1] == allLCClasses[Idx],]$diff.est


        barUncData[Idx] = tabInfo[tabInfo[,1] == allLCClasses[Idx],]$diff.SEleft
        if (barData[Idx] > 0) {
          barUncData[Idx] = tabInfo[tabInfo[,1] == allLCClasses[Idx],]$diff.SEright
        }        
        
        if (barData[Idx] == 0) {
          barLabels[Idx] = paste0(setDecPlaces(barData[Idx],0),"%")  
        } else {
          barLabels[Idx] = paste0(setDecPlaces(barData[Idx],3),"%")  
        }
      } # end if/check for non-existent data

    } # end if/check for LU or LC
    
    barColors[Idx] = "red"
    if (barData[Idx] > 0) {
      barColors[Idx] = "blue"
    } 
  } # end for loop over ALL Classes

  # set up y-axis increments and ticks 
  ymin = min(c(barData,barUncData),na.rm=TRUE)
  ymax = max(c(barData,barUncData),na.rm=TRUE)

  magnitude = max(c(abs(ymin),abs(ymax)))*1.20 # make room for bar labels

  ymin = (-1)*magnitude
  ymax = magnitude

  yticks = pretty(c(ymin,ymax))

  ymin = yticks[1]
  ymax = tail(yticks,n=1)

  # set up plot layout - in this case, 1 panel with room for title at top
  subpanel_coords = matrix(NA,nrow=1,ncol=4) # nrow = nSubPanels
                                             # ncol = L,R,B,T

#  subpanel_coords[1,1] = 0.05
#  subpanel_coords[1,2] = 0.95 
  minHorizSideSpace = 0.05
  addlHorizSideSpace = (14-nClasses)*minHorizSideSpace/2

  subpanel_coords[1,1] = minHorizSideSpace + addlHorizSideSpace
  subpanel_coords[1,2] = 1.0 - minHorizSideSpace - addlHorizSideSpace
  subpanel_coords[1,3] = 0.03
  subpanel_coords[1,4] = 0.80

  invisible(split.screen(subpanel_coords)) # invisible suppresses the "##[1] 1 2" output

  screen(1)
      
  # bottom, left, top, and right
  par(mar=c(3,2,0,0)) # leave space for class names along xaxis and room for % labels 
                      # along yaxis

  # plot the gains and losses for each ICE LU or LC class in a bar graph
  barp = barplot(barData,col = barColors,ylim=c(ymin,ymax), 
                 beside=TRUE,horiz=FALSE,space=0.25,axes=FALSE,
                 xlab="",ylab="",font=1,las=1,ann=FALSE,names.arg=NA)
  
  #write.csv(barp,file=paste0("plotNetChangesByClass_",datatype,".csv"))

  # add uncertainty data (95 CI)
  xcoords = barp[,1]
  par(xpd=NA)
  for (i in 1:length(xcoords)) {
    yLo = min(c(barData[i],barUncData[i]))
    yHi = max(c(barData[i],barUncData[i]))
    lines(x=rep(xcoords[i],2),y=c(yLo,yHi),col='darkgrey',lwd=4)
  }
  
  # add data values as labels at the end of bars.
  labPosn = 1 # below bar by default
  for (i in 1:length(barData)) {
    if (barData[i] < 0) {
      labPosn = 1 # label losses with % loss below the bar
    } else {
      labPosn = 3 # label gains with %gain above the bar
    } # end check for zero/nonzero data value

    text(x=barp[i,1], y=barData[i], labels=barLabels[i], xpd=NA,cex=0.65,pos=labPosn)
  }

  # custom labels and positioning for x-axis
  xcoords = barp[,1]

  par(xpd=NA) # allow plotting/annotation outside figure region

  if (datatype == 'LU') {
    prettyClassLabs = allLUClassLabs
  } else if (datatype == 'LC') {
    prettyClassLabs = allLCClassLabs
  }

  text(x=xcoords,y=ymin-(ymax-ymin)*0.23,cex=0.6,srt=45,labels=prettyClassLabs,col=classLabCol)

  # custom y-axis labels, ticks and overall axis title
  # --> determine max num of decimal places to display
  maxNDecPlaces = 0
  for (ytickIdx in 1:length(yticks)) {
    currN = getNPrettyDecPlaces(yticks[ytickIdx])
    if(currN > maxNDecPlaces) {
      maxNDecPlaces = currN
    }
  } # end for loop over yticks

  par(xpd=NA) # allow plotting/annotation outside figure region
  axis(2,at=yticks,labels=paste0(setDecPlaces(yticks,maxNDecPlaces),"%"),
       las=2,cex.axis=0.9,tck=-0.050,mgp=c(3,0.5,0))

  # add reference lines to plot
  par(xpd=FALSE) # restrict plotting to figure region; otherwise ref. lines will go outside fig region.
  abline(h=yticks,lty="dotted",col="gray")
  abline(h=0,lty="solid",col="black")

  # add barplot a 2nd time, so as to have bars covering up reference lines (cleaner look)
  barp = barplot(barData,col = barColors,ylim=c(ymin,ymax), 
                 beside=TRUE,horiz=FALSE,space=0.25,axes=FALSE,
                 xlab="",ylab="",font=1,las=1,ann=FALSE,names.arg=NA,add=TRUE)

  # add legend to explain that gray line = 95% confidence interval
  par(xpd=NA) # allow drawing outside of box plot area
  # legend("topright",
  #                   legend=c("95% Confidence Interval"),
  #                   col=c("darkgray"),
  #                   lty=c("solid"),lwd=3,
  #                   bty='n',text.col="black",cex=0.8,horiz=TRUE,
  #                   inset=c(-0.00,-0.15))

  legend("topleft",
                    legend=c("Gain","Loss"),
                    col=c("blue","red"),
                    pch=c(15,15),
                    pt.cex=1.5,x.intersp=1.0,
                    bty='n',text.col="black",cex=0.8,horiz=TRUE,
                    inset=c(0,-0.15))
        
  box()


  # flush out graphics
  close.screen(all.screens=TRUE)
    
  # add overall figure title
  title(main=figTitle,line=3,cex.main=1.2)
    
} 




##********** End of plotNetChangesByClass function ***********************************###
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#





#==================================================================================================
# plotGainLossSingClass function: plot gain and loss for a single class of LU or LC
#===================================================================================================
# Input(s): type of data (LU = Land Use, LC = Land Class), 
# Grouping type w/in the dataset (used to determine field from which to pull data)
# Full path to filename for input csv, the class for which we want a bar chart
# Output(s): bar chart, with gains and losses for the class in question (class2Plot)


plotGainLossSingClass = function(datatype='LU',grouping='fine',
                                 inFile=NULL,
                                 class2Plot='Forest') {

  tabInfo = inFile
  
  # file structure change on 4/9/2018 in estimate files - code around these
  category = unlist(strsplit(tabInfo$gain.val,split=" to "))
  category = category[seq(2,length(category),by=2)] # get only even elements on the right hand side of the "to" equation

  tabInfo = cbind(category, tabInfo)
  tabInfo$gain.SEright <- tabInfo$gain.est + tabInfo$gain.se
  tabInfo$gain.SEleft <- tabInfo$gain.est - tabInfo$gain.se
  tabInfo$loss.SEright <- tabInfo$loss.est + tabInfo$loss.se
  tabInfo$loss.SEleft <- tabInfo$loss.est - tabInfo$loss.se

  gainVal = tabInfo[tabInfo[,1] == class2Plot,]$gain.est
  lossVal = (tabInfo[tabInfo[,1] == class2Plot,]$loss.est)*(-1) # loss is reported as + val in TF tables
  
  gainUncVal = tabInfo[tabInfo[,1] == class2Plot,]$gain.SEright
#  lossUncVal = tabInfo[tabInfo[,1] == class2Plot,]$loss.CI95left
  lossUncVal = tabInfo[tabInfo[,1] == class2Plot,]$loss.SEright*(-1) # loss CI's are reported as positive in TF tables

  barData = as.numeric(c(gainVal,lossVal))
  barUncData = as.numeric(c(gainUncVal,lossUncVal))

  # set up y-axis increments and ticks
  ymin = min(c(barData,barUncData),na.rm=TRUE)
  ymax = max(c(barData,barUncData),na.rm=TRUE)

  magnitude = max(c(abs(ymin),abs(ymax)))*1.20 # make room for bar labels

  ymin = (-1)*magnitude
  ymax = magnitude

  yticks = pretty(c(ymin,ymax))

  ymin = yticks[1]
  ymax = tail(yticks,n=1)

  # xmin, xmax
  xmin = 0
  xmax = 3
  
  # set up colors
  colorsInRamp = c("blue","red") # blue = gain, red = loss
  colRamp = colorRampPalette(colorsInRamp)

  # bar plot itself
  barp = barplot(barData,col = colRamp(length(barData)),
                 ylim=c(ymin,ymax),beside=TRUE,horiz=FALSE,space=0.25,axes=FALSE,
                 xlab="",font=1,las=1,cex.names=1.1,xlim=c(xmin,xmax))

  # add uncertainty data (95 CI)
  xcoords = barp[,1]
  par(xpd=NA)
  for (i in 1:length(xcoords)) {
    yLo = min(c(barData[i],barUncData[i]))
    yHi = max(c(barData[i],barUncData[i]))
    lines(x=rep(xcoords[i],2),y=c(yLo,yHi),col='darkgrey',lwd=6)
  }
  
  # add data values as labels at the end of bars.
  labPosn = 3 # above bar by default
  for (i in 1:length(barData)) {
    if (barData[i] == 0) { # don't label 0%'s
      barLab = paste0(setDecPlaces(barData[i],0),"%")
    } else {
      barLab = paste0(setDecPlaces(barData[i],3),"%")

      if (barData[i] < 0) {
        labPosn = 1 # label losses with % loss below the bar
      } else {
        labPosn = 3 # label gains with %gain above the bar
      }
    } # end check for zero/nonzero data value

    text(x=barp[i,1], y=barData[i], labels=barLab, xpd=NA,cex=1,pos=labPosn)
  }

  # custom y-axis labels, ticks and overall axis title

  # --> determine max num of decimal places to display
  maxNDecPlaces = 0
  for (ytickIdx in 1:length(yticks)) {
    currN = getNPrettyDecPlaces(yticks[ytickIdx])
  
    if(currN > maxNDecPlaces) {
      maxNDecPlaces = currN
    }
  } 
  par(xpd=NA) # allow plotting/annotation outside figure region
 
  axis(4,at=yticks,labels=paste0(setDecPlaces(yticks,maxNDecPlaces),"%"),
       las=2,cex.axis=0.9,tck=-0.050,mgp=c(3,0.5,0))

  # add reference lines to plot
  par(xpd=FALSE) # restrict plotting to figure region; otherwise ref. lines will go outside fig region.
  abline(h=yticks,lty="dotted",col="gray")
  abline(h=0,lty="solid",col="black")

  
  # add barplot a 2nd time, so as to have bars covering up reference lines (cleaner look)
  barp = barplot(barData,col = colRamp(length(barData)),
                 ylim=c(ymin,ymax),beside=TRUE,horiz=FALSE,space=0.25,axes=FALSE,
                 xlab="",font=1,las=1,cex.names=1.1,xlim=c(xmin,xmax),add=TRUE)
 
  # add legend to explain that gray line = 95% confidence interval
  par(xpd=NA) # allow drawing outside of box plot area
#  legend("top",legend=c("95% Conf. Interval"),col="darkgray",lty="solid",lwd=3,
#      bty='n',text.col="black",cex=0.6,ncol=1,inset=c(-0.08,-0.08),xjust=1)
  
  legend("top",
         legend=c("Gain","Loss"),
         col=c("blue","red"),
         pch=c(15,15),
         pt.cex=1.5,x.intersp=1.0,
         bty='n',text.col="black",cex=0.8,horiz=TRUE,
         inset=c(-0.08,-0.15))
   
  # add a "b" in lower left corner of bar graph for reference
  bX = xmin + (xmax-xmin)*0.0001
  bY = ymin + (ymax-ymin)*0.05
  
  # text(x=bX,y=bY,labels="b", cex = 1.4)
  
  box()
} 


##********** End of plotGainLossSingClass function ***********************************###
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#



##********* Checkerboard function ***************************************************###
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#

plotCheckerboard = function(datatype='LU',inFile,
                            use1nm, use2nm, cover1nm, cover2nm,
                            allClasses = as.character(0),
                            allClassesPretty=as.character(0),
                            cellWidth=NA,cellHeight=NA) {

  if (invisible(is.null(inFile))) {
    print("missing args - Need a data file, with full path")
    quit()
  }  

  if (length(allClasses) == 0) { 
    print("missing args - need a vector of class names")
    quit()
  }
  
  if (length(allClassesPretty) == 0) { 
    print("missing args - need a vector of pretty class names for labeling rows & columns")
    quit()
  }    

  if (is.na(cellWidth)) {
    print("missing args - need a user-defined cell width")
    quit()
  } 

  if (is.na(cellHeight)) {
    print("missing args - need a user-defined cell height")
    quit()
  } 

  tabInfo = inFile

  nClasses = length(allClasses)

  xmax = cellWidth*(nClasses+1.5)
  ymax = cellHeight*(nClasses+1.5)

  #par(mar = c(0, 5, 0, 0)+.1) # leave room for T1 and T2 Class Names at left and top
  
  # set up grid of rectangles that will be colored by gain/loss
  plot(xmax,ymax,typ='n',xlim=c(0,xmax),ylim=c(0,ymax),xaxt='n',yaxt='n',
       ann=FALSE,bty='n')

  for (T1Idx in 1:nClasses) {
    T1 = allClasses[T1Idx]

    for (T2Idx in 1:nClasses) {
      T2 = allClasses[T2Idx]

      # figure out rectangle vertices for this cell
      rectXCoord = c(T2Idx-1,T2Idx,T2Idx,T2Idx-1)*cellWidth
      rectYCoord = c((nClasses+1)-T1Idx,
                     (nClasses+1)-T1Idx,
                     (nClasses+1)-T1Idx+1,
                     (nClasses+1)-T1Idx+1)*cellHeight 

      # add label to rectangle.      
      labX = mean(c(T2Idx-1,T2Idx))
      labY = mean(c((nClasses+1)-T1Idx,
                    (nClasses+1)-T1Idx+1))

      if (datatype == 'LU') { 
        estStr = tabInfo[tabInfo[[use1nm]] == T1 & tabInfo[[use2nm]] == T2,]$est
        seStr = tabInfo[tabInfo[[use1nm]] == T1 & tabInfo[[use2nm]] == T2,]$est.se
        yaxTitle = "Land Use"
      } else if (datatype == 'LC') {
        estStr = tabInfo[tabInfo[[cover1nm]] == T1 & tabInfo[[cover2nm]] == T2,]$est
        seStr = tabInfo[tabInfo[[cover1nm]] == T1 & tabInfo[[cover2nm]] == T2,]$est.se
        yaxTitle = "Land Cover"
      } else {
        print("you said datatype != LU and datatype != LC... need to specify datatype = LU or LC")
        quit()
      }  

      if (length(estStr) != 1) {
        estStr = NA
      }
    
      if (length(seStr) != 1) {
        seStr = NA
      }
      # defaults
      cellLabel = ""  
      rectColor="white"
      drawRect = FALSE

      # T1/T2 combo not found in TF table for this AOI
      if (is.na(estStr) & is.na(seStr)) { 
        rectColor = "white"
        cellLabel = ""
   
        drawRect = TRUE
      } 

      # persistence on the diagonal of the matrix
      if (T1Idx == T2Idx && !(is.na(estStr) & is.na(seStr)) ) { 
        rectColor = "gray"
        if (setDecPlaces(estStr,2) == 0 && estStr > 0.005) {
          cellLabel = paste0(setDecPlaces(estStr,2),"*\n",
                          "(",setDecPlaces(seStr,2),")")
        } else {
          cellLabel = paste0(setDecPlaces(estStr,2),"\n",
                          "(",setDecPlaces(seStr,2),")")
        }
        drawRect = TRUE
      } 

      # change occurred - plot orange cell 
      if (T1Idx != 1 && T2Idx != 1 && 
          T1Idx != T2Idx && (!(is.na(estStr) & is.na(seStr)) & !(estStr == 0 & seStr == 0))) {  
        rectColor = "orange"
        if (setDecPlaces(estStr,2) == "0.00") {
          cellLabel = paste0(setDecPlaces(estStr,2),"*\n",
                          "(",setDecPlaces(seStr,2),")")
        } else {
          cellLabel = paste0(setDecPlaces(estStr,2),"\n",
                          "(",setDecPlaces(seStr,2),")")
        }
        drawRect = TRUE
      } else {
        drawRect = TRUE
      }
      
      ## Totals 
      if ((T1Idx == 1 || T2Idx == 1) && !(is.na(estStr) && is.na(seStr)) ) { 
        if (setDecPlaces(estStr,2) == "0.00") {
          cellLabel = paste0(setDecPlaces(estStr,2),"*\n",
                          "(",setDecPlaces(seStr,2),")")
        } else {
          cellLabel = paste0(setDecPlaces(estStr,2),"\n",
                          "(",setDecPlaces(seStr,2),")")
        }
        #drawRect = TRUE
        polygon(x=rectXCoord,y=rectYCoord,col=rectColor)  
        text(x=labX,y=labY,labels=cellLabel,col="black",cex=0.8, font=2)

      } else {
        #drawRect = TRUE
        polygon(x=rectXCoord,y=rectYCoord,col=rectColor)  
        text(x=labX,y=labY,labels=cellLabel,col="black",cex=0.8)
      }

      # if (drawRect) {
      #   polygon(x=rectXCoord,y=rectYCoord,col=rectColor) 
      #   text(x=labX,y=labY,labels=cellLabel,col="black",cex=0.8)
      # }
    
      # Add T1 class name to left of grid
      if ((T2Idx %% nClasses) == 1) {

        if(datatype=='LU') { # note to self: need to scale these values by nClasses
          xLabOffset = 1
        } else { # LC
          xLabOffset = 1.5
        }
        
        xcoord = labX - xLabOffset 
        ycoord = labY

        par(xpd=NA)      
        text(x=xcoord,y=ycoord,labels=allClassesPretty[T1Idx],col="black",cex=0.9)

        # left side title
        if (T1Idx == 1 && T2Idx == 1) {
          text(x=xcoord,y=ycoord+0.75,labels=paste0("T1 ",yaxTitle),col="black",font=2)     
        }
      } # end if/write T1 class names along left of grid

      # Add T2 class name along top of grid
      if ((T1Idx %% nClasses) == 1) {

        if(datatype=='LU') { # note to self: need to scale these values by nClasses
          xLabOffset = 0.2
          yLabOffset = 1.5
        } else { # LC
          xLabOffset = 0.1
          yLabOffset = 1.5
        }
        
        xcoord = labX + xLabOffset
        ycoord = labY + yLabOffset

        par(xpd=NA)      
        text(x=xcoord,y=ycoord,labels=allClassesPretty[T2Idx],col="black",cex=0.9,srt=45)

        # top side title
        if (T1Idx == 1 && T2Idx == 1) {

          if (datatype=='LU') { # note to self: need to scale these values by nClasses
            yLabOffset = 1
          } else { # LC
            yLabOffset = 1
          }
          
          text(x=xcoord,y=ycoord+yLabOffset,labels=paste0("T2 ",yaxTitle),col="black",font=2)     
        }
      } # end if/write T1 class names along left of grid   
            
    } # end for loop over T2
  } # end for loop over T1

  par(xpd=NA) # allow drawing outside of figure region itself.

  legend("topright",
         legend=c("Persistence","Change\nOccurred",
                  paste0("Change\nCombination\nNot Present in\n",AOInm)),
         pt.cex=1.5,fill=c("gray","orange","white"), cex=1, bty='n', bg="white",
         inset=c(-0.05,0.05),y.intersp=1.4) 
} 


######################## Second plot #####################################################

plotCheckerboard2 = function(datatype='LU',inFile,
                            use1nm, use2nm, cover1nm, cover2nm,
                            allClasses=as.character(0),
                            allClassesPretty=as.character(0),
                            cellWidth=NA,cellHeight=NA) {

  if (invisible(is.null(inFile))) {
    print("missing args - Need a data file, with full path")
    quit()
  }  

  if (length(allClasses) == 0) { 
    print("missing args - need a vector of class names")
    quit()
  }
  
  if (length(allClassesPretty) == 0) { 
    print("missing args - need a vector of pretty class names for labeling rows & columns")
    quit()
  }    

  if (is.na(cellWidth)) {
    print("missing args - need a user-defined cell width")
    quit()
  } 

  if (is.na(cellHeight)) {
    print("missing args - need a user-defined cell height")
    quit()
  } 

  tabInfo = inFile

  nClasses = length(allClasses)

  xmax = cellWidth*(nClasses+1.5)
  ymax = cellHeight*(nClasses+1.5)

  #par(mar = c(0, 5, 0, 0)+.1) # leave room for T1 and T2 Class Names at left and top
  
  # set up grid of rectangles that will be colored by gain/loss
  plot(xmax,ymax,typ='n',xlim=c(0,xmax),ylim=c(0,ymax),xaxt='n',yaxt='n',
       ann=FALSE,bty='n')

  for (T1Idx in 1:nClasses) {
    T1 = allClasses[T1Idx]

    for (T2Idx in 1:nClasses) {
      T2 = allClasses[T2Idx]

      # figure out rectangle vertices for this cell
      rectXCoord = c(T2Idx-1,T2Idx,T2Idx,T2Idx-1)*cellWidth
      rectYCoord = c((nClasses+1)-T1Idx,
                     (nClasses+1)-T1Idx,
                     (nClasses+1)-T1Idx+1,
                     (nClasses+1)-T1Idx+1)*cellHeight 

      # add label to rectangle.      
      labX = mean(c(T2Idx-1,T2Idx))
      labY = mean(c((nClasses+1)-T1Idx,
                    (nClasses+1)-T1Idx+1))

      if (datatype == 'LU') { 
        estStr = tabInfo[tabInfo[[use1nm]] == T1 & tabInfo[[use2nm]] == T2,]$est
        seStr = tabInfo[tabInfo[[use1nm]] == T1 & tabInfo[[use2nm]] == T2,]$est.se
        yaxTitle = "Land Use"
      } else if (datatype == 'LC') {
        estStr = tabInfo[tabInfo[[cover1nm]] == T1 & tabInfo[[cover2nm]] == T2,]$est
        seStr = tabInfo[tabInfo[[cover1nm]] == T1 & tabInfo[[cover2nm]] == T2,]$est.se
        yaxTitle = "Land Cover"
      } else {
        print("you said datatype != LU and datatype != LC... need to specify datatype = LU or LC")
        quit()
      }  

      if (length(estStr) != 1) {
        estStr = NA
      }
    
      if (length(seStr) != 1) {
        seStr = NA
      }
      # defaults
      cellLabel = ""  
      rectColor="white"
      drawRect = FALSE

      # T1/T2 combo not found in TF table for this AOI
      if (is.na(estStr) & is.na(seStr)) { 
        rectColor = "white"
        cellLabel = ""
   
        drawRect = TRUE
      } 

      # persistence on the diagonal of the matrix
      if (T1Idx == T2Idx && !(is.na(estStr) & is.na(seStr)) ) { 
        rectColor = "gray"
        if (setDecPlaces(estStr,2) == 0 && estStr > 0.005) {
          cellLabel = paste0(setDecPlaces(estStr,2),"*\n",
                          "(",setDecPlaces(seStr,2),")")
        } else {
          cellLabel = paste0(setDecPlaces(estStr,2),"\n",
                          "(",setDecPlaces(seStr,2),")")
        }
        drawRect = TRUE
      } 

      # change occurred - plot orange cell 
      if (T1Idx != 1 && T2Idx != 1 && 
          T1Idx != T2Idx && (!(is.na(estStr) & is.na(seStr)) & !(estStr == 0 & seStr == 0))) { 
        rectColor = "orange"
        if (setDecPlaces(estStr,2) == "0.00") {
          cellLabel = paste0(setDecPlaces(estStr,2),"*\n",
                          "(",setDecPlaces(seStr,2),")")
        } else {
          cellLabel = paste0(setDecPlaces(estStr,2),"\n",
                          "(",setDecPlaces(seStr,2),")")
        }
        drawRect = TRUE
      } else {
        drawRect = TRUE
      }
      
      # Totals 
      if ((T1Idx == 1 || T2Idx == 1) && !(is.na(estStr) && is.na(seStr)) ) { 
        if (setDecPlaces(estStr,2) == "0.00") {
          cellLabel = paste0(setDecPlaces(estStr,2),"*\n",
                          "(",setDecPlaces(seStr,2),")")
        } else {
          cellLabel = paste0(setDecPlaces(estStr,2),"\n",
                          "(",setDecPlaces(seStr,2),")")
        }
        #drawRect = TRUE
        polygon(x=rectXCoord,y=rectYCoord,col=rectColor)  
        text(x=labX,y=labY,labels=cellLabel,col="black",cex=0.8, font=2)

      } else {
        #drawRect = TRUE
        polygon(x=rectXCoord,y=rectYCoord,col=rectColor)  
        text(x=labX,y=labY,labels=cellLabel,col="black",cex=0.8)
      }

      # if (drawRect) {
      #   polygon(x=rectXCoord,y=rectYCoord,col=rectColor) 
      #   text(x=labX,y=labY,labels=cellLabel,col="black",cex=0.8)
      # }
      # 
      
      # Add T1 class name to left of grid
      if ((T2Idx %% nClasses) == 1) {

        if(datatype=='LU') { # note to self: need to scale these values by nClasses
          xLabOffset = 2
        } else { # LC
          xLabOffset = 1.6
        }
        
        xcoord = labX - xLabOffset 
        ycoord = labY

        par(xpd=NA)      
        text(x=xcoord,y=ycoord,labels=allClassesPretty[T1Idx],col="black",cex=0.9)

        # left side title
        if (T1Idx == 1 && T2Idx == 1) {
          text(x=xcoord,y=ycoord+0.75,labels=paste0("T1 ",yaxTitle),col="black",font=2)     
        }
      } # end if/write T1 class names along left of grid

      # Add T2 class name along top of grid
      if ((T1Idx %% nClasses) == 1) {

        if(datatype=='LU') { # note to self: need to scale these values by nClasses
          xLabOffset = 0
          yLabOffset = 2
        } else { # LC
          xLabOffset = 0.1
          yLabOffset = 1.5
        }
        
        xcoord = labX + xLabOffset
        ycoord = labY + yLabOffset

        par(xpd=NA)      
        text(x=xcoord,y=ycoord,labels=allClassesPretty[T2Idx],col="black",cex=0.9,srt=90)

        # top side title
        if (T1Idx == 1 && T2Idx == 1) {

          if (datatype=='LU') { # note to self: need to scale these values by nClasses
            yLabOffset = 1
          } else { # LC
            yLabOffset = 1
          }
          
          text(x=xcoord,y=ycoord+yLabOffset,labels=paste0("T2 ",yaxTitle),col="black",font=2)     
        }
      } # end if/write T1 class names along left of grid   
            
    } # end for loop over T2
  } # end for loop over T1

  par(xpd=NA) # allow drawing outside of figure region itself.

  legend("topright",
         legend=c("Persistence","Change\nOccurred",
                  paste0("Change\nCombination\nNot Present in\n",AOInm)),
         pt.cex=1.5,fill=c("gray","orange","white"), cex=1, bty='n', bg="white",
         inset=c(-0.05,0.05),y.intersp=1.4) 
} 




###### End of plotCheckerboard function ##################################################  




##********** END OF PLOT FUNCTIONS ***************************************************###
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#





#=========================================================================================================
###### Everything below is adding text, data to plots using functions created above ######################
# The above code are custom data and plot functions 
# Below we fill in plots using the functions above with FIA input data, and with the addition of plot text
#=========================================================================================================

```




```{r getSummaryInfo,echo=FALSE,include=TRUE}

#===================================================================================================================
# Forest LU and Tree LC summary: This chunk is specific to forest LU and LC. Other LU summary info is in next chunks
#===================================================================================================================

# --------------------------------------------------------------------------------
#  * estimate for AOI for T1
#  *   + uncertainty info
#  * estimate for AOI for T2
#  *   + uncertainty info
#  * direction of T1 --> T2 change (decrease or increase)
#  * wording to describe the change in classes from T1 to T2, depending on whether it was incr. or decr.


### Create an empty dataframe and fields to populate (summaryInfo dataframe) 
## The following code populates the fields created below in the summaryInfo dataframe 
# -------------------------------------------------------------------------------------
summaryInfo = as.data.frame(matrix(nrow=1,ncol=24))
names(summaryInfo) = c("forLuEstT1",
                       "forLuUncT1",
                       "forLuEstT2",
                       "forLuUncT2",
                       "forLuAmtChange",
                       "forLuAmtChangeUnc",
                       "forLuAmtChangeAnn",
                       "forLuAmtChangeAnnUnc",
                       "forLuAmtChangeNet",
                       "forLuDecrIncr",
                       "forLuClassDescT1",
                       "forLuClassDescT2",
                       "treeLcEstT1",
                       "treeLcUncT1",
                       "treeLcEstT2",
                       "treeLcUncT2",
                       "treeLcAmtChange",
                       "treeLcAmtChangeUnc",
                       "treeLcAmtChangeAnn",
                       "treeLcAmtChangeAnnUnc",
                       "treeLcAmtChangeNet",
                       "treeLcDecrIncr",
                       "treeLcClassDescT1",
                       "treeLcClassDescT2")



## INPUT 6: Time 1 Land Use estimation and uncertainty 
# -------------------------------------------------------------------------------------
summaryInfo[1,]$forLuEstT1 = Input6[Input6[[use1nm]] == "Forest",]$est
summaryInfo[1,]$forLuUncT1 = Input6[Input6[[use1nm]]== "Forest",]$est.se


## INPUT 7: Time 2 Land Use estimation and uncertainty 
# -------------------------------------------------------------------------------------
summaryInfo[1,]$forLuEstT2 = Input7[Input7[[use2nm]] == "Forest",]$est
summaryInfo[1,]$forLuUncT2 = Input7[Input7[[use2nm]] == "Forest",]$est.se



## INPUT 8: LU net change and uncertainty associated w/ LU net change
# The LU net change value goes in figure 3 box plot
# This value goes into Figure 3 boxplot Forest LU loss/gain --- see Notes concerning question about this
# ------------------------------------------------------------------------------------------
category = unlist(strsplit(Input8$gain.val,split=" to "))
category = category[seq(2,length(category),by=2)] # get only even elements on the right hand side of the "to" equation

Input8 = cbind(category, Input8)

summaryInfo[1,]$forLuAmtChange = Input8[Input8[,1] == 'Forest',]$diff.est
summaryInfo[1,]$forLuAmtChangeUnc = Input8[Input8[,1] == 'Forest',]$diff.se

## Average annual change 
summaryInfo[1,]$forLuAmtChangeAnn = summaryInfo[1,]$forLuAmtChange / (REMPER)
summaryInfo[1,]$forLuAmtChangeAnnUnc = sqrt(summaryInfo[1,]$forLuAmtChangeUnc^2 / (REMPER)^2)

## Net change 
summaryInfo[1,]$forLuAmtChangeNet = (summaryInfo[1,]$forLuEstT1 - summaryInfo[1,]$forLuEstT2) / summaryInfo[1,]$forLuEstT1 * 100


## INPUT 9: Determines if LU change decrease or increased based on forLuAmtChange field value in SummaryInfo table
# Change in LU between two years is populated into "forLuDecrIncr" field
# The type of LU class that changed is populated into "forLuClassDescT1/T2" fields 
# Forest land use is row one, hence index [1,]
# -----------------------------------------------------------------------------------------------

if (summaryInfo[1,]$forLuAmtChange == 0) {
  summaryInfo[1,]$forLuDecrIncr = "did not change"
  summaryInfo[1,]$forLuClassDescT1 = NA
  summaryInfo[1,]$forLuClassDescT2 = NA

} else if (summaryInfo[1,]$forLuAmtChange < 0) {

  summaryInfo[1,]$forLuDecrIncr = "decreased"
  summaryInfo[1,]$forLuClassDescT1 = 'Forest'

  # figure out what Forest changed to; leave out any T1=0/T2=0 (never present) combos
  classesT2 = Input9[Input9[[use1nm]] == 'Forest' & 
                      Input9[[use2nm]] != 'Forest' &
                      Input9$est != 0,][[use2nm]]

  # build string to describe what Forest changed to
  if (length(classesT2) == 1) {
    classesT2Str = classesT2[1]
  } else if (length(classesT2) == 2) {
    classesT2Str = paste0(classesT2[1]," and ",classesT2[2])
  } else { # > 2 
   
    classesT2Str = classesT2[1]
    for (i in 2:(length(classesT2)-1)) {
      classesT2Str = paste0(classesT2Str,", ",classesT2[i])
    }
    classesT2Str = paste0(classesT2Str,", and ",classesT2[length(classesT2)])
    
    summaryInfo[1,]$forLuClassDescT2 = classesT2Str

  } # end if/building string to describe what Forest changed to
  
} else { # if (summaryInfo[1,]$forLuAmtChange > 0) {

  summaryInfo[1,]$forLuDecrIncr = "increased"
  summaryInfo[1,]$forLuClassDescT2 = 'Forest'

  # figure out what classes changed from somethign else to Forest
  classesT1 = Input9[Input9$use_2_nm == 'Forest' & 
                      Input9$use_1_nm != 'Forest' &
                      Input9$est != 0,]$use_1_nm

  # build string to describe what Forest changed to
  if (length(classesT1) == 1) {
    classesT1Str = classesT1[1]
  } else if (length(classesT1) == 2) {
    classesT1Str = paste0(classesT1[1]," and ",classesT1[2])
  } else { # > 2 
   
    classesT1Str = ""
    for (i in 1:(length(classesT1)-1)) {
      classesT1Str = paste0(classesT1Str,",")
    }

    classesT1Str = paste0(classesT1Str," and ",classesT1[length(classesT1)])
    
    summaryInfo[1,]$forLuClassDescT1 = classesT1Str
  } # end if/building string to describe what classes changed to Forest
} # end if/determine if Forest increased, decreased or stayed the same. 

if (summaryInfo[1,]$forLuAmtChange == 0) {
  forLuChgStmt = ""
  forLuChgStmt1 = ""
} else { # there was change
  forLuChgStmt = paste0("by ",setDecPlaces(summaryInfo[1,]$forLuAmtChange,3),"%  (+/-",
                              setDecPlaces(summaryInfo[1,]$forLuAmtChangeUnc,3),"%)",
                   " due to conversion of lands from ",
                   summaryInfo[1,]$forLuClassDescT1," to ",
                   summaryInfo[1,]$forLuClassDescT2)

  forLuChgStmt1 = paste0(
                   "This change was due to conversion of lands from ",
                   summaryInfo[1,]$forLuClassDescT1," to ",
                   summaryInfo[1,]$forLuClassDescT2," LU.")
} # end if/define Forest LU change statement


## INPUT 10: Percent of Tree Landcover (LC) for T1 (Year 1)
# ----------------------------------------------------------------------------------------------
summaryInfo[1,]$treeLcEstT1 = Input10[Input10[[cover1nm]] == "Tree - Live",]$est
summaryInfo[1,]$treeLcUncT1 = Input10[Input10[[cover1nm]] == "Tree - Live",]$est.se


## INPUT 11: Percent of Tree Landcover (LC) for T2 (Year 2)
# ----------------------------------------------------------------------------------------------
summaryInfo[1,]$treeLcEstT2 = Input11[Input11[[cover2nm]] == "Tree - Live",]$est
summaryInfo[1,]$treeLcUncT2 = Input11[Input11[[cover2nm]] == "Tree - Live",]$est.se



## INPUT 12: Tree LC Net Change and Tree LC net change uncertainty 
# Difference between "treeLcEstT1" field (year 1) and "treeLcEstT2" (year 2): Year 1 - Year 2 = percent change in tree LC
# ----------------------------------------------------------------------------------------------

category = unlist(strsplit(Input12$gain.val,split=" to "))
category = category[seq(2,length(category),by=2)] # get only even elements on the right hand side of the "to" equation

Input12 = cbind(category, Input12)

summaryInfo[1,]$treeLcAmtChange = Input12[Input12[,1] == 'Tree - Live',]$diff.est
summaryInfo[1,]$treeLcAmtChangeUnc = Input12[Input12[,1] == 'Tree - Live',]$diff.se


## Average annual change 
summaryInfo[1,]$treeLcAmtChangeAnn = summaryInfo[1,]$treeLcAmtChange / (T2 - T1)
summaryInfo[1,]$treeLcAmtChangeAnnUnc = sqrt(summaryInfo[1,]$treeLcAmtChangeUnc^2 / (T2 - T1)^2)

## Net change 
summaryInfo[1,]$treeLcAmtChangeNet = (summaryInfo[1,]$treeLcEstT1 - summaryInfo[1,]$treeLcEstT2) / summaryInfo[1,]$treeLcEstT1 * 100


## INPUT 13: Overall tree LC increase or decrease -- What forest changed to for T1 and T2 (year1 and year 2) 
# ----------------------------------------------------------------------------------------------

if (summaryInfo[1,]$treeLcAmtChange == 0) {
  summaryInfo[1,]$treeLcDecrIncr = "did not change"
  summaryInfo[1,]$treeLcClassDescT1 = NA
  summaryInfo[1,]$treeLcClassDescT2 = NA

} else if (summaryInfo[1,]$treeLcAmtChange < 0) {

  summaryInfo[1,]$treeLcDecrIncr = "decreased"
  summaryInfo[1,]$treeLcClassDescT1 = 'Tree'

  # figure out what Tree LC changed to; leave out any T1=0/T2=0 (never present) combos
  classesT2 = Input13[Input13[[cover1nm]] == 'Tree - Live' & 
                      Input13[[cover2nm]] != 'Tree - Live' &
                      Input13$est != 0,][[cover2nm]]

  # build string to describe what Tree changed to
  if (length(classesT2) == 1) {
    classesT2Str = classesT2[1]
  } else if (length(classesT2) == 2) {
    classesT2Str = paste0(classesT2[1]," and ",classesT2[2])
  } else { # > 2 
   
    classesT2Str = classesT2[1]
    for (i in 2:(length(classesT2)-1)) {
      classesT2Str = paste0(classesT2Str,", ",classesT2[i])
    }
    classesT2Str = paste0(classesT2Str,", and ",classesT2[length(classesT2)])
    
    summaryInfo[1,]$treeLcClassDescT2 = classesT2Str

  } # end if/building string to describe what Forest changed to
  
} else { # if (summaryInfo[1,]$treeLcAmtChange > 0) {

  summaryInfo[1,]$treeLcDecrIncr = "increased"
  summaryInfo[1,]$treeLcClassDescT2 = 'Tree'

  # figure out what classes changed from somethign else to Tree
  classesT1 = Input13[Input13$cover_2_nm == 'Tree - Live' & 
                      Input13$cover_1_nm != 'Tree - Live' &
                      Input13$est != 0,]$cover_1_nm

  # build string to describe what Tree changed to
  if (length(classesT1) == 1) {
    classesT1Str = classesT1[1]
  } else if (length(classesT1) == 2) {
    classesT1Str = paste0(classesT1[1]," and ",classesT1[2])
  } else { # > 2 
   
    classesT1Str = ""
    for (i in 1:(length(classesT1)-1)) {
      classesT1Str = paste0(classesT1Str,",")
    }

    classesT1Str = paste0(classesT1Str," and ",classesT1[length(classesT1)])
    
    summaryInfo[1,]$forLuClassDescT1 = classesT1Str
  } # end if/building string to describe what classes changed to Tree
} # end if/determine if Tree increased, decreased or stayed the same. 

if (summaryInfo[1,]$treeLcAmtChange == 0) {
  treeLcChgStmt1 = ""
} else { # there was change

  treeLcChgStmt1 =   treeLcChgStmt1 = paste0(
                   "This change was due to conversion of lands from ",
                   summaryInfo[1,]$treeLcClassDescT1," to: ",
                   summaryInfo[1,]$treeLcClassDescT2," LC.")

} # end if/define Tree LC change statement

```


```{r getInput21,echo=FALSE,include=FALSE}

## Input 21: T2 Cover heatmap setup 

d = data.frame(Input21[,-1],row.names = Input21[,1], check.names = FALSE)

## Convert to matrix for heat map 
d = as.matrix(d, replace=TRUE)


d2 = data.frame(Input22[,-1],row.names = Input22[,1], check.names = FALSE)

## Convert to matrix for heat map 
d2 = as.matrix(d2, replace=TRUE)

## Round values to first decimal 
#mat = round(as.numeric(d),1)

```



---
title: "Image-based Change Estimation (ICE) Summary for `r AOInm`, `r yearT1` to `r yearT2`"
---

&nbsp;
&nbsp; 

__Date:__ `r format(Sys.time(), "%B %d, %Y")`

&nbsp;
&nbsp;


#### Overview

The Image-based Change Estimation (ICE) project from the USDA Forest Service, Forest Inventory and Analysis (FIA) Program provides information about land use and land cover composition and the causes of landscape changes. The ICE protocol is a relatively quick and simple, image-based approach of producing reliable estimates of land cover and land use change for a population. Data are collected using multi-date image interpretation of sample plot locations. The plot design used for this project consists of a plot center and a 144-foot radius plot.    


ICE data for land use, land cover, and agent of change were collected for the population of `r AOInm`, on all lands. To determine and analyze land use, land cover, and agent of change for `r AOInm`, National Agriculture Imagery Program (NAIP) imagery was interpreted from `r yearT1` and `r yearT2`. Estimates were generated using the *FIESTA* R Package (Frescino et al. 2023).   


Over the analysis period (`r yearT1` and `r yearT2`), Forest land use in `r AOInm` `r summaryInfo[1,]$forLuDecrIncr` by `r setDecPlaces(summaryInfo[1,]$forLuAmtChangeNet,3)`%, from `r paste0(setDecPlaces(summaryInfo[1,]$forLuEstT1, 3),"%", "(+/-",setDecPlaces(summaryInfo[1,]$forLuUncT1,3)," SE)")` in `r yearT1` to `r paste0(setDecPlaces(summaryInfo[1,]$forLuEstT2, 3),"%", "(+/-",setDecPlaces(summaryInfo[1,]$forLuUncT2,3)," SE)")` in `r yearT2`; this is an average annual change of `r paste0(setDecPlaces(abs(summaryInfo[1,]$forLuAmtChangeAnn),3), "% (+/-",setDecPlaces(summaryInfo[1,]$forLuAmtChangeAnnUnc,3)," SE)")`. Tree land cover in `r AOInm` `r summaryInfo[1,]$treeLcDecrIncr` by `r setDecPlaces(summaryInfo[1,]$treeLcAmtChangeNet,3)`%, from `r paste0(setDecPlaces(summaryInfo[1,]$treeLcEstT1, 3),"%", "(+/-",setDecPlaces(summaryInfo[1,]$treeLcUncT1,3)," SE)")` in `r yearT1` to `r paste0(setDecPlaces(summaryInfo[1,]$treeLcEstT2, 3),"%", "(+/-",setDecPlaces(summaryInfo[1,]$forLuUncT2,3)," SE)")` in `r yearT2`; this is an average annual change of `r paste0(setDecPlaces(abs(summaryInfo[1,]$treeLcAmtChangeAnn),3), "% (+/-",setDecPlaces(summaryInfo[1,]$treeLcAmtChangeAnnUnc,3)," SE)")`. 
 

<br>

#### Land Use 

```{r echo=FALSE}
df19max <- df19[df19$est < 100 & df19[[use1nm]] != "TOTAL" & df19[[use2nm]] != "TOTAL"
			& df19[[use1nm]] != df19[[use2nm]], ]
df19max <- df19max[df19max$est == max(df19max$est, na.rm=TRUE),]

```


Land use describes the management and modification of the land. Figure `r figNum+1` shows the estimated land use change for `r AOInm` between `r yearT1` and `r yearT2` among all land use classes. This provides information on transitional changes across the state by category. Here, we see the highest change in land use in `r AOInm` between `r yearT1` and `r yearT2` was  *`r df19max[[use1nm]]`* to *`r df19max[[use2nm]]`*, with an estimated `r round(df19max$est, 2)`% (`r paste(round(df19max$est.se, 2), "SE)")`. The orange cells represent transitions where change occurred.  


&nbsp;

````{r luCheckerboard,echo=FALSE,fig.height=8,fig.width=11.5, dpi=300, fig.alt="Matrix with estimates of land use change from Time 1 to Time2."}


#===================================================================================================================
# Figure 7 - Checkerboard 1 
#===================================================================================================================


##titleStr = paste0("Estimated Land Use Changes for ", AOInm,
               ## " Between ",yearT1," and ",yearT2,",\nAmong All Land Use Classes")



# set up layout to accommodate grid itself + T1 and T2 class names/labels
# set up multi-paneled plot layout
subpanel_coords = matrix(NA,nrow=1,ncol=4) # nrow = nSubPanels
                                           # ncol = L,R,B,T
# subpanel #1
subpanel_coords[1,1] = 0.05
subpanel_coords[1,2] = 0.95 
subpanel_coords[1,3] = 0.0
subpanel_coords[1,4] = 0.9



invisible(split.screen(subpanel_coords))

# subpanel #1 - checkerboard itself (only 1 panel in this graphic)
screen(1)

par(mar = c(0, 5, 0, 0))


par(oma = c(0, 0, 0, 0))


object = plotCheckerboard2(datatype='LU',inFile=df19,
                 use1nm=use1nm, use2nm=use2nm,
                 cover1nm=cover1nm, cover2nm=cover2nm,
                 allClasses = c("TOTAL", allLUClasses),
                 allClassesPretty = c("Total", allLUClassLabs),
                 cellWidth=1,cellHeight=1)
 
##axis(1,pos=1)
##axis(2,pos=1)


# close up subpanel screens
close.screen(all = TRUE)

# add overall figure title
##title(main=titleStr,line=0,cex.main=1.5)

````


```` {r luCheckerboardCapGen,include=FALSE}
figNum = figNum + 1
figCap = paste0("Figure ",figNum,": Estimated percent land use for ", AOInm," from ",
                 yearT1," to ", yearT2, ", with standard error values in parentheses.",
                "*Less than 0.005%.")



````
########## `r figCap`

<br>

``` {r echo=FALSE}

highgain <- Input14[Input14$gain.est == max(Input14$gain.est, na.rm=TRUE), ]
highgain$category <- unlist(strsplit(highgain$gain.val,split=" to "))[2]

highloss <- Input14[Input14$loss.est == max(Input14$loss.est, na.rm=TRUE), ]
highloss$category <- unlist(strsplit(highloss$loss.val,split=" to "))[1]

forgain <- Input15[Input15$gain.val == "Not-Forest to Forest", ]
forloss <- Input15[Input15$loss.val == "Forest to Not-Forest", ]

```

Net change shows the overall change across `r AOInm`. Figure `r figNum+1` presents the net land use change among all classes for `r AOInm` (`r yearT1` to `r yearT2`). Here, the blue bars reflect a positive change and the red bars reflect a negative change. The largest net gain in `r AOInm` was *`r highgain$category`* land use with `r paste0(round(highgain$diff.est, 3), "% (", round(highgain$diff.se, 3), " SE)")`. The largest net loss in `r AOInm` was *`r highloss$category`* land use with `r paste0(round(highloss$diff.est, 3), "% (", round(highloss$diff.se, 3), " SE)")`. Figure `r figNum+2` focuses on forest land use change only showing a gain of `r paste0(round(forgain$gain.est, 3), " (", round(forgain$gain.se, 3), "% SE)")` and loss of `r paste0(round(forloss$loss.est, 3), "% (", round(forloss$loss.se, 3), " SE)")`.

&nbsp;
&nbsp;
``` {r luNetChange,echo=FALSE,fig.height=3,dpi=300, fig.alt="Bar plot showing net land cover change for all classes."}

#===================================================================================================================
# Figures 2 - are created from plot frameworks, and functions called above &
# plots data using plotNetChangesByClass function created above 
#===================================================================================================================


#===================================================================================================================
# Figure 2 - Net Land Use Change Among All Classes 
#===================================================================================================================

## Input 14: Net Land use change among all LU classes (Figure 2) 

# Figure 2 title 
titleStr=paste0("Net Land Use Change Among All Classes")

## plotNetChangesByClass function created above in non-forest function section 
plotNetChangesByClass(datatype='LU',inFile=Input14,figTitle=titleStr)
```

``` {r luNetChangeCapGen,include=FALSE}


# Figure 2 caption text  

figNum = figNum+1
figCap = paste0("Figure ",figNum,": Estimated percent net land use change for ",
                 AOInm, " for all classes from ",yearT1," to ",yearT2,".  ",
                "Class names in gray text were not captured by the sample in ", AOInm,
                ". Error bars represent one standard error (upper limit).")
```
########## `r figCap`
 


``` {r luForGainLoss_tab3,echo=FALSE,fig.height=4,dpi=300, fig.alt="Bar plot showing net land use change for forest land."}

#===================================================================================================================
# Figure 3 - Forest Land Use Change -- Title added, open map added &
# plots data using plotGainLossSingClass function created above 
#===================================================================================================================

## Input 15: Forest Land Use Change input (Figure 3) 


# Figure 3 title 
titleStr=paste("Forest Land Use Change")

# set up multi-paneled plot layout
subpanel_coords = matrix(NA,nrow=3,ncol=4) # nrow = nSubPanels
                                           # ncol = L,R,B,T
# subpanel #1
subpanel_coords[1,1] = 0.2
subpanel_coords[1,2] = 0.8 
subpanel_coords[1,3] = 0.03
subpanel_coords[1,4] = 0.95
invisible(split.screen(subpanel_coords)) 

# --> subpanel #2: plot bar graph
screen(1)

# bottom, left, top, and right
par(mar = c(0, 0, 4, 2))

plotGainLossSingClass(datatype='LU',grouping='fine',
                      inFile=Input15,
                      class2Plot='Forest') # maybe coarse???

# flush out graphics
close.screen(all.screens=TRUE)

# add overall figure title
title(main=titleStr,line=1.5,cex.main=1.2)
```

``` {r luForestGainLossCapGen,include=FALSE}

#===================================================================================================================
# Figure 3 - Forest Land Use Change cont'd -- This part adds in caption text 
#===================================================================================================================


figNum = figNum+1
figCap = paste0("Figure ",figNum,": Estimated percent of ", AOInm,
                "'s area that experienced Forest land use gain (left bar) and loss (right bar) between ",
                yearT1," and ",yearT2, ". Error bars represent one standard error (upper limit)." )

```
########## `r figCap`

<br>
<br>

#### Land Cover 

```{r echo=FALSE}
df20max <- df20[df20$est < 100 & df20[[cover1nm]] != "TOTAL" & df20[[cover2nm]] != "TOTAL"
			& df20[[cover1nm]] != df20[[cover2nm]], ]
df20max <- df20max[df20max$est == max(df20max$est, na.rm=TRUE),]

```


Land cover describes the physical land type observed on the ground. Figure `r figNum+1` shows the estimated land cover change for `r AOInm` between `r yearT1` and `r yearT2` among all land cover classes. This provides information on transitional changes across the state by category. Here, we see the highest change in land cover in `r AOInm` between `r yearT1` and `r yearT2` was  *`r df20max[[cover1nm]]`* to *`r df20max[[cover2nm]]`*, with an estimated `r round(df20max$est, 2)`% (`r paste(round(df20max$est.se, 2), "SE)")`. The orange cells represent transitions where change occurred.  


```{r lcCheckerboard,echo=FALSE,fig.height=7,fig.width=11.5,dpi=300, fig.alt="Matrix with estimates of land cover change from Time 1 to Time2."}

#===================================================================================================================
# Figure 8 - Checkerboard 2 
#===================================================================================================================




# set up layout to accommodate grid itself + T1 and T2 class names/labels
# set up multi-paneled plot layout
subpanel_coords = matrix(NA,nrow=1,ncol=4) # nrow = nSubPanels
                                           # ncol = L,R,B,T
# subpanel #1
subpanel_coords[1,1] = 0.0 
subpanel_coords[1,2] = 0.95 
subpanel_coords[1,3] = 0.0
subpanel_coords[1,4] = 0.87
invisible(split.screen(subpanel_coords))

# subpanel #1 - checkerboard itself (only 1 panel in this graphic)
screen(1)

## bottom, left, top, and right
par(mar = c(0, 5, 0, 0))

plotCheckerboard(datatype='LC',inFile=df20,
                 use1nm=use1nm, use2nm=use2nm, 
                 cover1nm=cover1nm, cover2nm=cover2nm,
                 allClasses = c("TOTAL", allLCClasses),
                 allClassesPretty = c("Total", allLCClassLabs),
                 cellWidth=1,cellHeight=1)

# close up subpanel screens
close.screen(all = TRUE)

# add overall figure title
#title(main=titleStr,line=.6,cex.main=1.5)
```

``` {r lcCheckerboardCapGen,include=FALSE}
figNum = figNum + 1
figCap = paste0("Figure ",figNum,": Estimated land cover change for ", 
                AOInm," ", yearT1," to ", yearT2, ", with standard error values in parentheses.",
                "*Less than 0.005%.")
#                "  (Data file: ",basename(dataFile),")")
```
########## `r figCap`


<br>

``` {r echo=FALSE}

LChighgain <- Input16[Input16$gain.est == max(Input16$gain.est, na.rm=TRUE), ]
LChighgain$category <- unlist(strsplit(LChighgain$gain.val,split=" to "))[2]

LChighloss <- Input16[Input16$loss.est == max(Input16$loss.est, na.rm=TRUE), ]
LChighloss$category <- unlist(strsplit(LChighloss$loss.val,split=" to "))[1]

LCtreegain <- Input17[Input17$gain.val == "Not-Tree to Tree", ]
LCtreeloss <- Input17[Input17$loss.val == "Tree to Not-Tree", ]

```


Figure `r figNum+1`  presents the net land cover change among all classes for `r AOInm` (`r yearT1` to `r yearT2`). Again, the blue bars reflect a positive change and the red bars reflect a negative change. The largest net gain in `r AOInm` was *`r LChighgain$category`* land cover with `r paste0(round(LChighgain$diff.est, 3), "% (", round(LChighgain$diff.se, 3), " SE)")`. The largest net loss in `r AOInm` was *`r LChighloss$category`* land cover with `r paste0(round(LChighloss$diff.est, 3), "% (", round(LChighloss$diff.se, 3), " SE)")`. Figure `r figNum+2` focuses on tree (live and dead standing) cover change only, with a gain of `r paste0(round(LCtreegain$gain.est, 3), " (", round(LCtreegain$gain.se, 3), "% SE)")` and loss of `r paste0(round(LCtreeloss$loss.est, 3), "% (", round(LCtreeloss$loss.se, 3), " SE)")`.


&nbsp;
&nbsp;
``` {r lcNetChange,echo=FALSE,fig.height=3,dpi=300, fig.alt="Bar plot showing net land cover change for all classes."}

#===================================================================================================================
# Figure 4 - Net Land Cover Change Among All Classes -- This part adds in caption text & 
# plots data using plotNetChangesByClass function created above  
#===================================================================================================================

## Input 16: Forest Land Use Change input (Figure 4) 

titleStr=paste0("Net Land Cover Change Among All Classes")


plotNetChangesByClass(datatype='LC',inFile=Input16,figTitle=titleStr)
```
``` {r lcNetChangeCapGen,include=FALSE}
figNum = figNum+1
figCap = paste0("Figure ",figNum,": Estimated percent net land cover change for ",
                 AOInm, " for all classes from ",yearT1," to ",yearT2,".  ",
                "Class names in gray text were not captured by the sample in ", AOInm,
                ". Error bars represent upper 95% confidence interval.")
```
########## `r figCap`


``` {r lcTreeGainLoss,echo=FALSE, fig.height=4,dpi=300, fig.alt="Bar plot showing net land cover change for tree (live and standing dead) cover change."}

#===================================================================================================================
# Figure 5 - Tree Land Cover Change -- This part adds in caption text &
# plots data using plotGainLossSingClass function created above 
#===================================================================================================================

## Input 17: Forest Land Use Change input (Figure 5) 

titleStr=paste("Tree (Live and Standing Dead) Cover Change")

# set up multi-paneled plot layout
subpanel_coords = matrix(NA,nrow=3,ncol=4) # nrow = nSubPanels
                                           # ncol = L,R,B,T
subpanel_coords[1,1] = 0.2
subpanel_coords[1,2] = 0.8 
subpanel_coords[1,3] = 0.03
subpanel_coords[1,4] = 0.95
invisible(split.screen(subpanel_coords))

# --> subpanel #2: plot bar graph
screen(1)

# bottom, left, top, and right
par(mar = c(0, 0, 4, 2))

plotGainLossSingClass(datatype='LC',inFile=Input17,
                      grouping='coarse',
                      class2Plot='Tree')

# flush out graphics
close.screen(all.screens=TRUE)

# add overall figure title
title(main=titleStr,line=1.5,cex.main=1.2)
```

``` {r lcTreeGainLossCapGen,include=FALSE}

#===================================================================================================================
# Figure 5 - Forest Land Use Change -- This part adds in caption text & 
#===================================================================================================================

figNum = figNum+1
figCap = paste0("Figure ",figNum,
                ": Estimated percent of ", AOInm,
                "'s area that experienced tree (live and standing dead) cover gain (left bar) and loss (right bar) between ",
                yearT1," and ",yearT2,". Error bars represent one standard error (upper limit).")
                
```
########## `r figCap`


<br>
<br>


#### Agent of Change

Figure `r figNum+1` displays the percent change by agent of change for `r AOInm` from `r yearT1` to `r yearT2`. The largest agent of change across `r AOInm` was *`r Input18[Input18$est == max(Input18$est, na.rm=TRUE), agentnm]`* with `r paste0(round(Input18[Input18$est == max(Input18$est, na.rm=TRUE), "est"],2), "%  (", round(Input18[Input18$est == max(Input18$est, na.rm=TRUE),"est.se"],2), " SE)")` change in percentage points.

``` {r chgAgBarChart,echo=FALSE, fig.height=3,  dpi=300, fig.alt="Bar plot showing percent change by agent of change from Time 1 to Time 2."}

#===================================================================================================================
# Figure 6 - Percent of Area Changed, by Agent of Change -- This part adds in caption text &
# plots data using plotGainLossSingClass function created above 
#===================================================================================================================

## Input 18: Forest Land Use Change input (Figure 6) 

# Don't include "No Change"
tabInfo = Input18[Input18[[agentnm]] != 'No Change',]
tabInfo$SEleft <- tabInfo$est - tabInfo$est.se
tabInfo$SEright <- tabInfo$est + tabInfo$est.se

barData = as.numeric(tabInfo$est)
barLabels = tabInfo[[agentnm]]

# replace "Stress" with "Stress and Mortality" on the y axis labels
barLabels[barLabels == 'Stress'] = 'Stress and Mortality'

# set xticks to accommodate CIs, which extend beyond the bars themselves 
xLeft = min(tabInfo$SEleft,na.rm=TRUE)
if (min(tabInfo$SEleft,na.rm=TRUE) < 0) {
  xLeft = 0
}

xticks = pretty(c(xLeft,
                max(tabInfo$SEright,na.rm=TRUE))) 

xmin = xticks[1] 
xmax = tail(xticks,n=1)

# set color ramp
colorsInRamp = c("darkgray","white")
colRamp = colorRampPalette(colorsInRamp)

# add bar plot to graphic, with margins to accommodate labels and titles.
# bottom, left, top, and right
par(mar=c(3,7,2,1))
barp = barplot(rev(barData),col = rev(colRamp(length(barData))),xlim=c(xmin,xmax),
               beside=FALSE,horiz=TRUE,
               space=0.25,axes=FALSE,
               xlab="",names.arg=rev(barLabels),font=1,las=1,cex.names=0.8)

# add 95% confidence intervals
ycoords = rev(barp[,1])
par(xpd=NA)
for (i in 1:length(ycoords)) {
#  xLeft = max(0,tabInfo$CI95left[i])
  xLeft = max(0,barData[i])
  lines(x=c(xLeft,tabInfo$SEright[i]),y=rep(ycoords[i],2))
}

# add reference lines
par(xpd=FALSE)
abline(v=xticks,lty="dotted",col="gray")

# add legend to explain that black line = 95% confidence interval
#par(xpd=NA) # allow drawing outside of box plot area
#legend("topright",legend=c("95% Confidence Interval"),col="black",lty="solid",
#      bty='n',text.col="black",cex=0.8,ncol=1,inset=c(0.00,-0.25))

# add x-axis ticks and labels
axis(1,at=xticks,labels=paste0(setDecPlaces(xticks,1)," %"))

# add y-axis title
#axis(2,at=median(ycoords),labels=c("Agent of Change"),
#     las=3,cex.axis=1.2,font=2,mgp=c(3,7,0),tick=FALSE) # default mgp = 3,1,0

# Add Main title.
#par(xpd=FALSE)
##mtext(text=paste0("Percent of Area Changed, by Agent of Change"),
      ##side=3,line=2,font=2,cex=1.5)

box()
```


``` {r aocCapGen,include=FALSE}  
figNum = figNum + 1
figCap = paste0("Figure ",figNum,": Estimated percent area of ", AOInm,
                 " that changed between ",yearT1," and ",yearT2,
                 " by agent of change, on all lands. Error bars represent one standard error (upper limit).")
                 
```
########## `r figCap`

\newpage


<br>
<br>

#### Land Use and Land Cover

``` {r echo=FALSE}

LChigh2nm <- row.names(d)[1]
LChigh2 <- sort(d[1,], decreasing=TRUE)[1:2]

LUhigh2nm <- row.names(d2)[1]
LUhigh2 <- sort(d2[row.names="Tree - Live",], decreasing=TRUE)[1:2]

```

Now, let's look at land cover and land use together for `r AOInm`, `r yearT2`. Figure `r figNum+1` shows percent of land cover (X axis) within land use classes (Y axis), while figure `r figNum+2` shows percent land use (X axis) within land cover classes (Y axis) across `r AOInm`. In Figure 8 we see the largest amount of land cover within *`r LChigh2nm`* land use is *`r names(LChigh2[1])`* with `r LChigh2[1]`% cover, followed by *`r names(LChigh2[2])`* with `r LChigh2[2]`% cover. Similarly, *`r names(LUhigh2[1])`* is the largest land use within the *`r LUhigh2nm`* land cover with *`r LUhigh2[1]`% cover, followed by *`r names(LUhigh2[2])`* with `r LUhigh2[2]`% cover (Figure 9). 

&nbsp;
&nbsp;
```{r T2-LCover_LUse,echo=FALSE, fig.height=4.5, fig.width = 10, dpi=300, fig.alt="Matrix showing percent land cover within land use classes."}

# #===================================================================================================================
# # Figure 9 - Heatmap 
# #===================================================================================================================
# 
col1 = colorRampPalette(c("gray50", 'gray90'))(10)
if (any(colSums(d) == 0)) {
  d[1, colSums(d) == 0] <- 0.0001
}
pheatmap(d[, nrow(d):1], display_numbers = T,
         cluster_rows = FALSE, cluster_cols = FALSE,
         treeheight_col = 0,
         treeheight_row = 0,
         cutree_cols = 5,
         cutree_rows = 6,
         clustering_distance_cols = "correlation",
         clustering_distance_rows = "correlation",
         color = col1,
         border_color = "Black",
         cellwidth = 40,
         cellheight = 20,
         xlab = "Land use",
         ylab = "Land class",
         fontsize = 14,
         fontsize_row = 10,
         fontsize_col = 10,
         fontsize_number = 8,
         angle_col = 45,
         number_color = "Black",
         number_format = "%.1f",
         legend = TRUE,
         scale = "none",
         legend_breaks = c(0, 20, 40, 60, 80, 100, max(d)),
         legend_labels = c("0", "20", "40", "60", "80", "100", "\n"),
         na_col = "Black"
)
```


``` {r T2LCCapGen,include=FALSE}
figNum = figNum + 1
figCap = paste0("Figure ",figNum,": The percent of ", AOInm,
                 " land cover (X axis) within different land use classes (Y axis) in ", yearT2,
                 ". Lighter shaded cells represent higher percentage of land cover within a given",
                 " land use.")
```

########## `r figCap`

<br>


&nbsp;
&nbsp;
```{r T2-LUse_LCover,echo=FALSE, fig.height=4.5, fig.width = 10, dpi=300, fig.alt="Matrix showing percent land use within land cover classes."}

# #===================================================================================================================
# # Figure 10 - Heatmap 
# #===================================================================================================================
# 
col1 = colorRampPalette(c("gray50", 'gray90'))(10)
if (any(colSums(d2) == 0)) {
  d2[1, colSums(d2) == 0] <- 0.0001
}
pheatmap(d2[, nrow(d2):1], display_numbers = T,
         cluster_rows = FALSE, cluster_cols = FALSE,
         treeheight_col = 0,
         treeheight_row = 0,
         cutree_cols = 5,
         cutree_rows = 6,
         clustering_distance_cols = "correlation",
         clustering_distance_rows = "correlation",
         color = col1,
         border_color = "Black",
         cellwidth = 40,
         cellheight = 20,
         xlab = "Landuse1",
         ylab = "Landuse2",
         fontsize = 14,
         fontsize_row = 10,
         fontsize_col = 10,
         fontsize_number = 8,
         angle_col = 45,
         number_color = "Black",
         number_format = "%.1f",
         legend = TRUE,
         scale = "none",
         legend_breaks = c(0, 20, 40, 60, 80, 100, max(d)),
         legend_labels = c("0", "20", "40", "60", "80", "100", "\n"),
         na_col = "Black"
)
```


``` {r T2LUCapGen,include=FALSE}
figNum = figNum + 1
figCap = paste0("Figure ",figNum,": The percent of ", AOInm,
                 " land use (X axis) within different land cover classes (Y axis) in ", yearT2,
                 ". Lighter shaded cells represent higher percentage of land use within a given",
                 " land cover.")
```

########## `r figCap`


<br>
<br>



#### Quality Assessment and Quality Control (QAQC) report

A quality assessment and quality control (QAQC) report was generated for `r AOInm` for `r yearT1` to `r yearT2` that compares agreement between original photo interpretations and blind re-interpretations by the same interpreter on the same plot (self checks), and also to blind interpretations made by another interpreter on the same plots (cross checks). The results are outlined below. If NA, no self or cross check occurred.

&nbsp;


```{r qctext, include=FALSE} 

chgtext <- "For presence of change, agreement was "
if (!is.null(QAQC.self)) {
  chgtext <- paste0(chgtext, QAQC.self[1], "% in self checks")
  if (!is.null(QAQC.cross)) {
    chgtext <- paste0(chgtext, " and ", QAQC.cross[1], "% in cross checks.")
  } else {
    chgtext <- paste0(chgtext, ".")
  }
} else {
  chgtext <- paste0(chgtext, QAQC.cross[1], "% in cross checks")
} 
LUtext <- "For land use Time 1 and Time 2, agreement was "
if (!is.null(QAQC.self)) {
  LUtext <- paste0(LUtext, QAQC.self[2], "% in self checks")
  if (!is.null(QAQC.cross)) {
    LUtext <- paste0(LUtext, " and ", QAQC.cross[2], "% in cross checks.")
  } else {
    LUtext <- paste0(LUtext, ".")
  }
} else {
  LUtext <- paste0(LUtext, QAQC.cross[2], "% in cross checks")
}
LCtext <- "For land cover Time 1 and Time 2, agreement was "
if (!is.null(QAQC.self)) {
  LCtext <- paste0(LCtext, QAQC.self[3], "% in self checks")
  if (!is.null(QAQC.cross)) {
    LCtext <- paste0(LCtext, " and ", QAQC.cross[3], "% in cross checks.")
  } else {
    LCtext <- paste0(LCtext, ".")
  }
} else {
  LCtext <- paste0(LCtext, QAQC.cross[3], "% in cross checks")
}
CAtext <- "For change agent, agreement was "
if (!is.null(QAQC.self)) {
  CAtext <- paste0(CAtext, QAQC.self[4], "% in self checks")
  if (!is.null(QAQC.cross)) {
    CAtext <- paste0(CAtext, " and ", QAQC.cross[4], "% in cross checks.")
  } else {
    CAtext <- paste0(CAtext, ".")
  }
} else {
  CAtext <- paste0(CAtext, QAQC.cross[4], "% in cross checks")
}

```


`r chgtext`  
`r LUtext`  
`r LCtext`  
`r CAtext`  


&nbsp;

For more information on the QAQC analysis, reference ICE_`r outfn.pre`_`r yearT1`_`r yearT2`_QAQC.xlsx


<br>
<br>



#### Glossary

_Agent of Change:_ Interpreted for each point that experienced change between the assessed time periods. Note: seasonal and expected changes, such as *Crop Rotation* and *High Water*, may be collected by interpreters but are not included in the change estimates reported.

_Land Cover:_ Assessed at each of the sample points to determine what type of cover is present at the sample point. No MMU is required for land cover.

_Land Use:_ Assessed at each of the sample points to determine what type of use is present. For land use, a minimum mapping unit (MMU) of 1.0 acres in size and greater than 120 feet wide must be met in order for select LUs to be recorded for each point.


<br>
<br>

#### Reference Information

Bechtold, W.A.; Patterson, P.L. [Editors] 2005. The enhanced forest inventory and analysis program - national sampling design and estimation procedures. Gen. Tech. Rep. SRS-80. Asheville, NC: U.S. Department of Agriculture, Forest Service, Southern Research Station. 85 p.  

Frescino, T.S.; Moisen, G.G.; Patterson, P.L.; Toney, C.; White, G.W. 2023. FIESTA. A Forest Inventory Estimation and Analysis R Package. Ecography Software Note [DOI: 10.1111/ecog.06428]. 

Patterson, P.L. 2012. Photo-based estimators for the Nevada photo-based inventory. Res. Pap. RMRS-RP-92. Fort Collins, CO: U.S. Department of Agriculture, Forest Service, Rocky Mountain Research Station. 14 p.

U.S. Department of Agriculture, Forest Service. 2016. Image-based Change Estimation (ICE) Protocol Guide, Version 3, 19 p. Unpublished protocol guide on file at: Geospatial Technology and Applications Center, Salt Lake City, Utah. 

<br>

